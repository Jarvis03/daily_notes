## linux base

### linux shell

#### ubuntu system

- 查看版本：`cat /etc/issue`
- 查看架构：`uname -m`
- 查看内核版本： `uname -r`

#### terminal

- `ctrl + alt + t` : 创建新终端

- `ctrl + shift + n` : 在相同路径下再开启新终端（必须有终端）

- `ctrl + shift + t`: 左右分屏打开同路径终端（必须有终端）

- 关闭终端：`exit` 或 `ctrl + d`

- `linux@ubuntu：～$` :如下表

  | linux | @ubuntu:| ~    | $    |
  | ------ | -------- | ---- | ---- |
  | 用户名 | 主机名   | 路径：`～`表示`home/`，`/`表示`root/` | 用户权限:`$`普通用户，`#`管理员 |



#### pack  manager

ubuntu 支持Ded包管理工具，常用工具包括`dpkg`，`apt`

##### dpkg

本地离线安装

- `-i`: 安装debian软件包
- `-r`: 移除已安装软件包
- `-P`: 移除已安装软件包和配置文件
- `-L`: 列出安装的软件包清单

##### apt

1. `etc/apt/source.list`是apt镜像的地址文件

2.  `var/lib/apt/lists`存放apt本地软件包的索引文件

3. `var/cache/apt/archives` 是apt本地缓存目录

- `update`:下载更新软件包列表信息

- `upgrade`:系统中所有的软件包升级到最新

- `install`: 下载所需软件包并进行安装

- `remove`: 卸载

- `clean`：清楚下载的软件包

  
  
* `apt-get --reinstall install`:重新安装

* `apt-get --purge remove`:完全卸载
  
* `apt-get -f install`: 修复软件包的依赖关系
  
#### base command

多个命令一行书写使用`：`

一条命令多行书写使用`\`

#####  cd

- `cd -`: 回到上次工作目录

##### mkdir

- `-p`:可以一次建立多个目录

##### cp  rm

- `-r`:递归删除
- `rm -rf`:删除目录名


##### ln

- `-s`:建立连接符号

##### tar

- `-c` : 打包
- `-x`：解包
- `-f`: 普通文件

- `-C`：指定路径

##### grep

`grep "string" * -nR`:当前目录下递归搜索

- `-I`：不区分大小写
- `-n`：显示匹配行以及行号
- `grep "h" ./ -r | less`:配合管道将其转到less（分页器）

##### find

`find 路径 -name filename`:从当前目录开始寻找指定文件

- `-name`: 支持通配符`*`和`？`  如`find ./ -name test*.c`

##### head 与tail

显示文件指定行：`head -line file | tail -1`

##### more 与 less

`q`:退出，less 支持字符查找：`/str`

##### wc

对文件内容进行统计

- `-c`: 字符数
- `-w`:单词数
- `-l`: 行数

##### cut

对字符串进行分割

- `-d`:指定分隔符
- `-f`:指定需要的区域

如截取`/etc/passwd`文件内的用户名：

`cat  /etc/passwd | cut -d ":" -f 1`

##### alias

定义别名

`alias listsoft = 'ls /var/cache/apt/archives'`

取消别名使用`unalias`

**配置文件**: `.bashrc` 、`.profile`

#### shell 基本配置

##### History

使用`history`命令可以将历史命令打印到终端，linux默认保存1000条历史记录，可以设置`HISTSIZE`来修改条数

 **永久修改** : 修改`、home/.bashrc` 的 HISTSIZE 并使用`source`命令使其生效

##### 环境变量

添加环境变量： `/etc/profile`中添加 `export PATH=/home/guo:$PATH`,然后使用`source`使其生效

##### 查看磁盘

如使用 `df -h` 查看各个磁盘，找到优盘，将其挂载到`/mnt`

如 `mount -t  vfat /dev/sdb4 /mnt`

##### 用户与组

- `/etc/passwd`可以识别用户清单，当用户登录时系统会查询这个文件

  `root: x: 1: 1:root,,,:/root:/bin/bash`

  | root   | x        | 1    | 1    | root,,,  | /root  | /binbash |
  | ------ | -------- | ---- | ---- | -------- | ------ | -------- |
  | 登录名 | 密码口令 | UID  | GID  | 个人信息 | 主目录 | shell    |

  

- `/etc/shadow`:加密的用户清单

- `/etc/group`:组名称和成员

  包含：组名，加密口令， GID，成员列表
  
  
  
  **常用命令**:
  
  `adduser`,`userdel`,`usermod`,`groupadd`,`groupdel`
##### 网络配置

`/etc/network/interfaces`文件可以进行配置，配置完成后使用`sudo /etc/init.d/networking restart`命令使其生效

### shell脚本

#### 基本过程

1. 建立`.sh` 后缀的文件
2. `chmod`修改文件权限
3. 脚本第一行`#！/bin/bash`

#### 变量

1. 用户自定义变量

   > 变量名=值    (**等号无空格**)

2. 位置参数

   `$0 $1....`

3. 预定义变量

   - `$#`:命令行参数的个数
   - `$@`:包含所有命令行参数：`$1$2$3..
   - `$?`:包含前一个命令的退出状态
   - `$*` :包含所有命令行参数：`$1$2$3..`
   - `$$`:包含正在执行的进程ID号

4. 环境变量

   `HOME`,`PATH`等等

#### 运算

##### 运算符

`+`，`-`，`\*`,`/`,`%`

##### 运算命令

`expr`

> 例如 add=\`expr $var1 + $var2\`

#### 判断

1. 字符串

   - `=`:相等 
   - `！=`：不等

   - `-z`:长度是否为0
   - `-n`：长度是否不为0

2. 数字
   - `-eq`：等于 `equal`
   - `-ne`: 不等于 `not equal`
   - `-gt`：大于`greater than`
   - `-ge`：大于等于`greater equal`
   - `-lt`：小于 `less than`
   - `-le`: 小于等于 `less epual`

#### 常见符号区别

- `${}`:变量替换

- `()`

  1. 命令组。括号中的命令将会新开一个子shell顺序执行，所以括号中的变量不能够被脚本余下的部分使用。括号中多个命令之间用分号隔开，最后一个命令可以没有分号，各命令和括号之间不必有空格。
  2. 命令替换 等同于\`\`，shell扫描一遍命令行，发现了`$(cmd)`结构，便将$`(cmd)`中的`cmd`执行一次，得到其标准输出，再将此输出放到原来命令。有些shell不支持，如`tcsh`。
  3. 用于初始化数组。如：`array=(a b c d)`

- `(())`

  1. 整数扩展。这种扩展计算是整数型的计算，不支持浮点型。((exp))结构扩展并计算一个算术表达式的值，如果表达式的结果为0，那么返回的退出状态码为1，或者 是"假"，而一个非零值的表达式所返回的退出状态码将为0，或者是"true"。若是逻辑判断，表达式exp为真则为1,假则为0。如`（（2*3））`

  2. 只要括号中的运算符、表达式符合C语言运算规则，都可用在`$((exp))`中，甚至是三目运算符。作不同进位(如二进制、八进制、十六进制)运算时，输出结果全都自动转化成了十进制。如：`echo $((16#5f))` 结果为95 (16进位转十进制)
  3. 单纯用 `(( ))` 也可重定义变量值，比如 `a=5; ((a++))` 可将 $a 重定义为6
  4. 常用于算术运算比较，双括号中的变量可以不使用$符号前缀。括号内支持多个表达式用逗号分开。 只要括号中的表达式符合C语言运算规则,比如可以直接使用`for((i=0;i<5;i++))`

  

- ` []`
  1. bash 的内部命令，[和test是等同的。如果我们不用绝对路径指明，通常我们用的都是bash自带的命令。if/test结构中的左中括号是调用test的命令标识，右中括号是关闭条件判断的。这个命令把它的参数作为比较表达式或者作为文件测试，并且根据比较的结果来返回一个退出状态码。if/test结构中并不是必须右中括号，但是新版的Bash中要求必须这样。
  2. Test和[]中可用的比较运算符只有==和!=，两者都是用于字符串比较的，不可用于整数比较，整数比较只能使用-eq，-gt这种形式。无论是字符串比较还是整数比较都不支持大于号小于号。如果实在想用，对于字符串比较可以使用转义形式，如果比较"ab"和"bc"：[ ab \< bc ]，结果为真，也就是返回状态为0。[ ]中的逻辑与和逻辑或使用-a 和-o 表示。
  3. 字符范围。用作正则表达式的一部分，描述一个匹配的字符范围。作为test用途的中括号内不能使用正则。
  4. 在一个array 结构的上下文中，中括号用来引用数组中每个元素的编号。
- `[[ ]]`
       
       1. `[[`是 bash 程序语言的关键字。并不是一个命令，`[[ ]]` 结构比`[ ]`结构更加通用。在`[[`和`]]`之间所有的字符都不会发生文件名扩展或者单词分割，但是会发生参数扩展和命令替换。
       2. 支持字符串的模式匹配，使用`=~`操作符时甚至支持shell的正则表达式。字符串比较时可以把右边的作为一个模式，而不仅仅是一个字符串，比如`[[ hello == hell? ]]`，结果为真。`[[ ]]` 中匹配字符串或通配符，不需要引号。
       3. 使用`[[ ... ]]`条件判断结构，而不是`[ ... ]`，能够防止脚本中的许多逻辑错误。比如，`&&,||,<,> `操作符能够正常存在于`[[ ]]`条件判断结构中，但是如果出现在`[ ]`结构中的话，会报错。比如可以直接使用`if [[ $a != 1 && $a != 2 ]]`, 如果不适用双括号, 则为`if [ $a -ne 1] && [ $a != 2 ]`或者`if [ $a -ne 1 -a $a != 2 ]`。
       4. bash把双中括号中的表达式看作一个单独的元素，并返回一个退出状态码。




